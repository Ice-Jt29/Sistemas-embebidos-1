/*
Ejercicio  - Sistemas Embebidos 1
Integrantes: Fabian polo , Jose Torres, Oscar pallares
Compilador usado: visual studio code
Descripción: 3.4.7.1. Caudalímetro
Desarrollar un programa que permita dar solución al siguiente problema:

En un proyecto de telemetría se tiene un caudalímetro que envía por puerto serial cada periodo de tiempo la cantidad de caudal detectado, el cual es un número entero no mayor de 2 dígitos (es decir, se enviará un número entre 00 y 99)

El caudalímetro envía la información en el siguiente formato:

{'caudal': VALOR}
Donde VALOR es el número que va entre 00 y 99. Una vez se recibe la información al microcontrolador, se debe imprimir por serial la siguiente información en el formato indicado:

{'último': ULTIMO, 'mayor': MAYOR, 'menor': MENOR, 'promedio': PROMEDIO}
Donde:

ULTIMO es el último número recibido.
MAYOR es el número mayor recibido.
MENOR es el número mínimo recibido.
PROMEDIO es el promedio de todos los números recibidos.
Un ejemplo de este programa es el siguiente:

{'último': 10, 'mayor': 10, 'menor': 10, 'promedio': 10.00}
{'último': 1, 'mayor': 10, 'menor': 1, 'promedio': 5.50}
{'último': 27, 'mayor': 27, 'menor': 1, 'promedio': 12.67}
En el anterior ejemplo, el caudalímetro usando el formato {'caudal': VALOR} ha enviado por serial 3 números en orden que son 10, 1 y 27. Donde al recibir el tercer dato (27), el número menor en ese momento es 1, el número mayor es 10, el último número recibido es 27 y el promedio de la sumatoria de todos los números recibidos es (10 + 1 + 27)/3 = 12.667

Restricciones:

Si se recibe algo diferente entre 00 y 99 (sea número o letra) se debe ignorar.
Si se envía algo diferente al formato {'caudal': VALOR}, se debe ignorar.
*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/uart.h"
#include "esp_log.h"

#define UART_PORT UART_NUM_0   // Usamos UART0 (USB por defecto en ESP32)
#define BUF_SIZE 1024
#define MAX_VALORES 100

static const char *TAG = "CAUDAL";

int valores[MAX_VALORES];
int count = 0;

// Verifica si el string es un número entero positivo
int esNumeroValido(const char *str) {
    if (strlen(str) == 0) return 0;
    for (int i = 0; str[i] != '\0'; i++) {
        if (!isdigit((unsigned char)str[i])) return 0;
    }
    return 1;
}

void procesarEntrada(char *input) {
    // Quitar espacios al inicio y fin
    while (isspace((unsigned char)*input)) input++;
    char *end = input + strlen(input) - 1;
    while (end > input && isspace((unsigned char)*end)) {
        *end = '\0';
        end--;
    }

    // Verificar formato {'caudal': VALOR}
    if (strncmp(input, "{'caudal':", 10) == 0 && input[strlen(input) - 1] == '}') {
        char valorStr[10];
        strncpy(valorStr, input + 10, sizeof(valorStr) - 1);
        valorStr[sizeof(valorStr) - 1] = '\0';

        // Eliminar llave final
        char *ptr = strchr(valorStr, '}');
        if (ptr) *ptr = '\0';

        while (isspace((unsigned char)*valorStr)) {
            memmove(valorStr, valorStr + 1, strlen(valorStr));
        }

        if (esNumeroValido(valorStr)) {
            int valor = atoi(valorStr);
            if (valor >= 0 && valor <= 99 && count < MAX_VALORES) {
                valores[count++] = valor;

                int ultimo = valor;
                int mayor = valores[0];
                int menor = valores[0];
                int suma = 0;

                for (int i = 0; i < count; i++) {
                    if (valores[i] > mayor) mayor = valores[i];
                    if (valores[i] < menor) menor = valores[i];
                    suma += valores[i];
                }
                double promedio = (double)suma / count;

                printf("{'último': %d, 'mayor': %d, 'menor': %d, 'promedio': %.2f}\n",
                       ultimo, mayor, menor, promedio);
            }
        }
    }
    // Si no cumple formato → ignorar
}

void app_main(void) {
    // Configuración UART0
    uart_config_t uart_config = {
        .baud_rate = 115200,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE
    };
    uart_param_config(UART_PORT, &uart_config);
    uart_driver_install(UART_PORT, BUF_SIZE * 2, 0, 0, NULL, 0);

    printf("ESP32 listo. Ingrese datos en formato {'caudal': VALOR} (0-99). Escriba 'fin' para salir.\n");

    uint8_t data[BUF_SIZE];
    char buffer[100];
    int index = 0;

    while (1) {
        int len = uart_read_bytes(UART_PORT, data, BUF_SIZE - 1, 20 / portTICK_PERIOD_MS);
        if (len > 0) {
            for (int i = 0; i < len; i++) {
                char c = (char)data[i];

                if (c == '\n' || c == '\r') {
                    buffer[index] = '\0';
                    index = 0;

                    if (strcmp(buffer, "fin") == 0 || strcmp(buffer, "FIN") == 0) {
                        printf("Programa terminado.\n");
                        vTaskDelay(portMAX_DELAY); // detener ejecución
                    }
                    procesarEntrada(buffer);
                } else {
                    if (index < (int)sizeof(buffer) - 1) {
                        buffer[index++] = c;
                    }
                }
            }
        }
    }
}
